# Updating
`rustup` is the general command to install, update, etc. e.g. `rustup update` & `rustup self uninstall`.

Local Rust documentation can be found by running `rustup doc`. This will open in your browser.

# Naming
Use snake_case for file names.



# Anatomy of a rust program
## Construction
The `main()` function is the program entry point just like C programs. It's always the first code that runs in every executable Rust program.

So with a simple program such as this:
```rust
fn main() {
    println!("hello world");
}
```

The `!` at the end of `println` indicates it's running as a macro. Will learn more about this later, but for now just note macros run by different rules than functions.

Additionally, most lines in Rust code ends with `;`.

## Compiling and running
These are separate steps; like with C programs after compiling there's an executable of the program that you'll run.

Rust is an "ahead-of-time compiled language" meaning you can build a program and send the executable for someone else to run (even without having Rust installed). Alternatively, in languages like Ruby, Javascript, and Python they'd need the respective languages installed in order to run the program, but compilation and running the program happens in one command.

# Cargo!
Rust's build system and package manager.

Cargo comes installed with Rust; `cargo --version`.

To create a cargo package run: `cargo new <project_name>`. This will generate a "binary application package" - a directory along with a Cargo.toml, .gitignore (if one hasn't already been initalized), and a `src/main.rs` file.

The `Cargo.toml` is Rust's config format. Packages (source code files) in Rust are referred to as crates. Cargo expects your source files to live in `src/`. This is why `main.rs` is auto-placed here. The top-level directory is for any files unrelated to code: i.e. README, config, license info, etc.

If you already have a directory, not generated by `cargo`, you can run `cargo init` to build it internally.

## Buildling and runing a cargo project
Instead of compiling your program manually - this would be complicated if you have multiple source files - you can simply run `cargo build` to compile the crate.

This will create an executable file in `target/debug/<project_name>` within your project directory. You can run the executable with `./target/debug/<project_name>`.

By building via cargo, you'll also have a `Cargo.lock` file in the top-level directory. This file keeps track of the exact versions of your deps in your project; cargo manages the contents of this file for you.

Alterntatively, you can more simply build and run the program in one swoop with `cargo run`.

Then to check code to make sure it compiles without generating an exectuable, run: `cargo check`. If you don't need to run the program - this is a must faster process as it doesn't ahve to build the executable. It's highly recommended to use this if you check your work as you go along, as you'll save a lot of time in the long run.

## Releasing cargo
`cargo build --release` to compile to an executable with optimizations. It'll also create an executable in `target/release` instead of `target/debug`. Notably, building for release takes longer because Rust is optimizing it so it's not recommended to use this regularly while in the development phase.


# Creating a larger program
Importing deps from the standard library can be done by  using `use` keyword at the top of your program. Rust has a set of items defined in the std library that it brings into the scope of every program, called the _prelude_; found here: https://doc.rust-lang.org/std/prelude/index.html. However, if what you need is not listed in here,  you'll need to manually import it. This is why the `println!` macro didn't need an import module earlier.

## Storing values and variables
You can declare variables with `let`. Variables are immutable by default, meaning once we give the variable a value it won't change (more about this in Ch. 3). However, to make a valuable mutable we add `mut` before the variable name:
```rust
let apples = 5; // immutable
let mut apples = 5; // mutable
```

You can associate functions to specific types (e.g. `String::new();`) which is kind of like a class method; you can apply some inherent function on the associated type. In the example, a new, empty `String` is generated.

`&` indicates that an argument is a _reference_, which gives you a way to let multiple parts of your code access one piece of data without needing to copy that data into memory multiple times. Like variables, references are immutable by default. Hence you'd need to write `&mut apples` instead of just `&apples` to make it mutable. More on references in chapter 4.

If a function produces a result - something like Err or Ok - you'll need to handle those cases with `.expect` which allows you to define which options produce what to the user; an error message or a note indicating success. Like C programs you have to handle these, otherwise you'll get a warning.

When printing the value of a variable, you can do so by simply placing the variable name in `{}` braces.

## Using crates
There's a difference between a binary crate - indented to be executed on its own - and a library crate to be used in other programs.

Before referencing a crate in your program, you have to add it as a dependency in your Cargo.toml file. E.g.
```rust
[dependencies]
rand = "0.8.5"
```

Importantly, if you were to update this dependency list, Cargo will only update up to 9.0 (if any beyond that exist). To retreive anything above 9.0 you'd need to note it explicitly: "0.9.0".

Cargo then fetches the latest versions of what we need from the registry, which is a copy of data from https://crates.io (the rust open source ecosystem).

Cargo will only use the versions of deps you specified until you indicate otherwise. This aids in protecting against dependency hell. E.g. lets say a new version of `rand` comes out, containing an important bug fix, but it'd cause your code to break  - this wouldn't be ideal. This is where the `Cargo.lock` file comes in; when Cargo builds your project, it notes the dependency versions in the `Cargo.lock` file which is quickly referenced later when you go to build the program again. This is important for reproducable builds so you want to include this in source like the rest of your code.

You can update your entire dependency list and the associated `Cargo.lock` versions by running `cargo update` in the project folder.

Run `cargo doc --open` to auto-build documentation of your dependency lists and view it in your local browser.

# Common programming concepts
## Variables and mutability
By default variables are immutable, as noted previously; this is one advantage with Rust, enhancing code safety.

Having immutable variables by default makes reasoning about variables across codebases much easier.

## Constants
Not just immutable by default; they're always immutable. Use `const` instead of `let` and the type keyword _must_ be annotated. They can also be declared in any scope, including global scope.

The last characteristic is that constants can be only set to a constant expression, not the result of a value that could only be computed at runtime. And they must be in all uppercase.

E.g. `const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;`

They're of course useful in a global context, allowing many parts of the program to know about them. It also makes updating constant values much easier than reinstantiating immutable variables peppered throughout the codebase.

## Shadowing
Means you can declare a new variable with the same name as a previous variable; i.e. the first variable is _shadowed_ by the second.

```rust
fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("The value of x in the inner scope is: {x}");
    }

    println!("The value of x is: {x}");
}
```

Output will be:
```
The value of x in the inner scope is: 12
The value of x is: 6
```

Because the inner scope leverages x, but since it's separated by braces after it executes, x will remain 6 as assigned with `let x = x + 1;`

Also note that shadowing is possible because we're using the `let` keyword to reassign x. This is of course different from using `mut` because with `mut` you don't have to redefine with `let`; the value is merely mutated.

The utlity of shadowing allows to refrain from comming up with different names for the same variables.

## Data types
Every value in rust is of a certain data type. Rust is a statically typed language, meaning it _must_ know the types of all variables at _compile time_.

### Scalar types
Represents a single value. Rust primarily has 4:
- integers
- floating-point numbers
- booleans
- characters

**Integer**
A number without a fractional component. Here are Rusts types:
Length                  Signed        Unsigned
8-bit                   i8            u8
16-bit                  i16           ...
32-bit                  ...
64-bit
128-bit
architecture dependent  isize

Number literals can use `_` as a visual separator to make numbers that would otherwise have a `.` easier to read; but both 1000 and 1_000 are handled the same way.

Practially, if you're unsure of which integer types to use it's fruitful to just go with Rusts' defaults: e.g. i32.

_Integer overflow_ occurs when you attempt to assign a value that's outside the length of the variable type. eg. assigning a value of say 271 to an `u8` integer which has the range of 0 to 255. This will cause your program to _panic_ at runtime, but the compiler should catch it.

**Boolean**
One byte in size, specified using `bool`; `let f: bool = false;`

**Character**
`char` is the most primitive alphabetic type. Here are some example declarations:
```rust
fn main() {
    let c = 'z';
    let z: char = 'Z';
    let heart_eyed_cat = '😻';
}
```

Characters are four bytes in size and represents a Unicode scalar value, which means it can represent a lot more than just ASCII.

### Compound types
Group multiple values into one type; rust has two primitive types: tuples and arrays.

**Tuple**
A way to group a number of values with a variety of types into one compound type. They have a fixed length; once declared they cannot grow or shrink in size.

E.g.
```rust
let main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
```

To access a value in the tuple you can either _destructure_ it by assigning each value in the tuple a variable then calling the variable or by referencing the value directly with a period `.` followed by the index of the value:

```rust
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
```

**Array**
Unlike a tuple, every element of an array must have the same type. Arrays also have fixed lengths.

They're written as comma-separated lists inside square brackets: `let a = [1, 2, 3, 4, 5];`

An array's cousin, a Vector, is more flexible as it can grow and shrink in size. It's able to do this because its contents exist on the heap; rather than the stack which is where the contents of an array live.

The trade-offs:
Arrays sacrifice flexibility for guaranteed performance and compile-time guarantees. If you know the size won't change, arrays eliminate an entire class of runtime overhead.

It's about choosing the right tool: arrays for speed and predictability, vectors for flexibility.

You write an array's type like so: `let a: [i32; 5] = [1, 2, 3, 4, 5];` where `i32` is the type of each element

You can access elements of anrray using indexing:
```rust
fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
```

## Functions
Declared with `fn` and names are written in snake_case, as with file names and variables.

Rust doesn't care about where you've defined your functions, only that they're defined somewhere within the scope seen by the caller.

In function signatures you must declare the type of each parameter. Separate multiple params with commas: `(value: i32, unit_label: char)`

Function bodies are construted with a series of statements optionally ending in an expression, defined as:
- Statements: instructions that perform some action and do not return a value
- Expressions: evaluate to a resultant value

Expressions do not include ending semicolons:
```rust
let y = {
    let x = 3;
    x + 1
};
```

If you add a semicolon to the end it'll turn into a statement, not returning a value.

### Returning values
Functions can return values to those that called them. You can't name return values, but you declare they're type with an arrow `->`. You can return early from a function using the `return` keyword and specifying a value.

```rust
fn five() -> i32 {
    5
}

fn main() {
    let x = five();

    println!("The value of x is : {x}");
}
```

## Control flow
### If expressions
Blocks of code associated with the conditions in `if` expressions are called _arms_, just like arms in a `match` expression. We can optionally include an `else` condition.

Because `if` is an expression we can use it on the right side of a `let` statement:
```rust
fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!("The value of number is: {number}");
}
```

Note that variables in an if statement must have a single type. So in the above example we couldn't replace 6 with `"six"`.

### Loops
`break` terminates the loop while `continue` will tell the program to skip over any remaining code in this iteration and go to the next.

You can use `break` to return a value as well:
```rust
fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("Result is {result}");
}
```

Alternatively, you can also use `return` to exit a loop an produce some result.

You can use _loop labels_ to address a specific loop (if you have more than one nested), used with `break` and `continue` like so:
```rust
fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!("count = {count}");
        let mut remaining = 10;

        loop {
            println!("remaining = {remaining}");
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1
    }
    println!("End count = {count}");
}
```

Use `while` to loop while a condition is true.

Helpful to use a `for` loop for iterating over an array (more efficent than usuing `while`):
```rust
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("the value is: {element}");
    }
}
```

# Ownership
A unique feature in Rust. It enables memory safety guarantees without needing a garbage collector.

It's a set of rules that governs how a Rust program manages memory. Some languages have garbage collection that regularly looks for no-longer-used memory as the program runs; in other languages, the programmer must explicitly allocate and free the memory. Rust uses a third approach: memory is managed through a system of ownership with a set of rules that the compiler checks. If any of the rules are violated, the program won’t compile. None of the features of ownership will slow down your program while it’s running.

Ownership forces you to think about the Stack and Heap (what's in memory at any given time). They're both available to your code to use at runtime, but they're sturctured in different ways. The stack stores values in the order it gets them and removes them in the  opposite order (i.e. last-in-first-out). All data stored on the stack must have a known, fixed size. Any data with an unknown size must be stored on the heap, which is less organized.

When you allocate to the heap, you request a certain amount of space. Malloc finds an empty spot in the heap that's big enough, marks it as being in use, then returns a pointer (the address at that location). This is called _allocating_. Because the pointer _to_ the heap is a known, fixed size, you can store the pointer on the stack, but when you need the actual data, you must go to the heap.

The stack is faster because the allocator never has to look for an empty space to store the data; that location is always at the top of the stack. Additionally, accessing data on the heap is slower too because you have to follow a pointer to get there.

The main purpose of ownership is to manage heap data.

## Rules
- Each value in Rust has an _owner_.
- There can only be one owner at a time.
- When the owner goes out of scope, the value will be dropped.

## Variable scope
A variable is valid (in scope) from the point at which it's declared until the end of the current _scope_.

## Memory and allocation
With a data type that has a variable size the memory must be requested from malloc at runtime (opposed to something like a string literal which is hardcoded into the program's exectuable at compile time). We also need a way to return this memory to the allocator when we're done using it.

Most languages have a garbage collector to handle the cleanup. However, these GCs come with serious overhead, reducing performance. Rust takes a different path: the memory is automatically returned once the variable that owns it goes out of scope. Rust calls `drop` when this happens, which happens automatically at the closing curly bracket. E.g.
```rust
{
    let s = String::from("hello"); // s is valid from this point forward as it's allocated to the heap

    // do stuff with s
} // this scope is now over, and s is no longer valid.
```

Similar to subject-oriented programming where what's in scope at any given point is of primary concern.

### Moves
When assigning, say, one string variable to another like in the example below, in Rust terms this is called a move because what's happening under the hood is that `s1` (made up of a pointer, lenght of the data in bytes, and capacity in bytes stored on the Stack) is simply moved to `s2` instead and the `s1` pointer and associated data is invalidated.

In other languages this would be called something like a _shallow copy_ (opposed to a deep copy where the data is physically copied in memory) which makes both variables point at the same data in memory. However, Rust doesn't allow this because without carefully freeing it properly you encounter what's called the _double free_ error, leading to memory corruption which can potentially lead to security vulnerabilities.

Hence it's called a _move_ and not a _copy_. This implies that Rust will never automatically create "deep" copies of your data so any automatic copying can be assumed to be inexpensive in terms of runtime performance.

### Scope and assignment
This _move_ behavior happens with "reassigned" variables, too. For instance:
```rust
let mut s = String::from("hello");
let s = String::from("ahoy");
```

The "hello" assigned to `s` is `drop`ped for `ahoy` instead.

### Cloning
If you want to deep copy the heap data of the String, not just the stack data (pointer, length, and capacity), you can use something called the `clone` method to do so.

This will make a hard copy in the heap and assign it to your variable:
```rust
let s1 = String::from("hellow");
let s2 = s1.clone();
```

### Stack-only copy
Types such as integers that have a known size at compile time are stored entirely on the stack, so copies of the actual values are quick to make. In this example `x` still remains independent of `y` and retains its value: 5.
```rust
let x = 5;
let y = x;
```

This works because integers have a special annotation called the `Copy` trait which applies to other types that are stored on the stack. If a type has the `Copy` trait, variables that use it do not `move`; rather are trivially copied onto the stack, making them still valid after assigning them to another variable.

Others that implement the `Copy` trait contain scalar attributes, meaning they don't require allocation. Some other types that contain this trait:
- Boolean
- Floating point
- Characters
- Tuples, if they also contain types that implement `copy`.

### Ownership and functions
Passing a variable to a function will move or copy it, just as assignment does. However, there's one strange quality that typifies the idea of ownership: if a variable of a non-scalar type (i.e. a String, array, etc.) is passed to another function, that variable goes out of scope. However, types that implement `Copy` do not go out of scope after being passed to another function.

```rust
fn main() {
    let s = String::from("hello"); // s comes into scope

    takes_ownership(s); // s goes out of scope

    let x = 5; // x comes into scope

    makes_copy(x); // x is still in scope after this.
}
```

## References and borrowing
Since variable values basically disappear after passing to a function, and it's common to have to reference that variable later on, Rust has what are called _references_ which allow you to call that data from memory. They're kind of like pointers except that a reference garantees to point to a valid value of a particular type for the life of the reference.

A reference is an address in memory:

```rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1); // reference to s1

    println!("The lenth of {s1} is {len}");
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```

As you can see the `&` indicate a reference and allow you to pass a referance of the data to a different function without passing over ownership of it. The opposite of referencing is dereferencing, with `*`, but we'll cover this later.

When a function merely accepts references rather than actual values there's no need to "pass back" any data to give back ownership because it never had ownership of the data.

The action of creating a reference is called _borrowing_. In line with this, when you pass a reference to a different function you can't modify it; just as variables are immutable by default, so are references.

### Mutable references
Just like a mutable variable, you explicitly state whether you're passing a mutable reference of the underlying value or not:

```rust
fn main() {
    let mut s = String:from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```

However, it's not possible to make multiple mutable references. This prevents data races.

Instead, if you need to refer to a mutable reference more than once, you'll want to section it out of scope before doing so, like:

```rust
let mut s = String::from("hello");

{
    let r1 = &mut s;
} // r1 goes out of scope here, so we can make a new reference without a problem

let r2 = &mut s;
```

## The slice type
String slices are nice to use in scenarios where you're needing to reference "chunks" of elements within a `String`. E.g. instead of having to implement functions that keep track of various indicies and the underlying String itself, you can use String Slices, which look like this:

```rust
let s = String::from("hello world");

let hello = &s[0..5];
let world = &s[6..11];
```

Rather than a reference to the entire string, you can slice it up by refering to specific portions of it. Explicitly, the grammar is `[starting_index..ending_index]`. Starting index is where to start and ending is one more than where to end.

You can also drop the 0 if you're referring to the beginning of a string (e.g. `[..4]`); similarly if your slice includes the last byte of the string, you can drop the trailing number: `[5..]`. And, can finally drop both indicies if you want to take the whole string: `[..]`.

Note: String slice range indices must occur at valid UTF-8 character boundaries. If you attempt to create a string slice in the middle of a multibyte character, your program will exit with an error.

It's also important to note that a string slice _is_ a reference. The type indicating a string slice is `&str`.

E.g.
```rust
fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[..i];
        }
    }

    &s[..]
}
```

A `String` is equivelant to a whole slice of a string so can be passed into a function that accepts a string slice:

```rust
let my_string = String:from("hello world");

let word = first_word(&my_string[..]);
let word = first_word(&my_string);

// It also works for string literals
let my_string_literal = "hello world";

let word = first_word(&my_string_literal[..]);
let word = first_word(my_string_literal);
```

Lastly, slices are not solely specific to strings; they can be applied to a number of other "collections" which will be covered later.

# Structs
## Defining and instantiating
Structs are similar to Tuples although you'll name the different types associated with it, making them more flexible as you don't have to rely on the ordering of the types when interacting with it. You can just reference the various parts by name. These parts are called _fields_.

```rust
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
```

Then to instantiate:
```rust
fn main() {
    let user1 = User {
        active: true,
        username: String::from("someusername"),
        email: String::from("someone@aol.com"),
        sign_in_count: 1,
    };
}
```

Then to access a field in a struct you can use dot `.` notiation: `user1.email`. If you mark the struct instance mutible you can change certain fields by simply calling the "arm". Note that you must make the entire struct mutable; it's not possible to only make parts of it as such.

There's a field init shorthand so you can avoid duplicating the same words:
```rust
fn build_user(email: String, username: String) -> User {
    User {
        active: true,
        username, // rather than username: username,
        email,  // or email: email,
        sign_in_count: 1,
    }
}
```

Similarly, there's an update syntax that allows you to reduce your code:

```rust
let user2 = User {
    email: String::from("another@aol.com"),
    ..user1  // assigns the remaining fields from user1 since they won't change
};
```

This shortcut must come last, but it doesn't matter what order the other fields are in the struct. This update syntax allow uses `=` (assignment) so the data from user1 to user2 would be _moved_; hence these data from user1 would no longer be valid.

### Tuple structs
You can build tuples similar to structs if you're in a scenario where you need to name the tuple, but don't need field names.

```rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}
```

### Non-field structs
Called _Unit-like_ structs.

```rust
struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}
```

### Debugging structs
An alternative to using `println!` is the `dbg!` macro which can be used without explicitly turning on struct-oriented debugging information in your code. But you need to pass the data going to `dbg!` as a reference because otherwise it would take ownership of the data. Inversely, `println!` only uses data as references so there's no need to manually pass in as references.

Additionally, `dbg!` prints out the file and line number to the terminal so it could be more useful in debugging scenarios.


## Methods
Like functions, but defined within the confines of a struct and their first parameter is always `self` which represents the instnace of the struct the method is being called on.

The main reason for using methods, opposed to loose functions, is to organize functions around specific types. It's a concise way to gather functions related to a specific type into one area of the code.

While it's possible to move ownership to a method, by default (an 99% of the time) you'll want to just pass a reference, written as `&self` in the method's function signature.

Also, note you can use the same name from a field to use for a method.

## Associated functions
Similar to methods, but don't have the `self` as a parameter. Often used for constructors that will return a new instance of the struct.

To call associated functions you use the `::` syntax, like `String::from("hello");`.

## Multiple impl blocks
Each struct is allowed to have multiple implmentation blocks.

# Enums and pattern matching
Enums give you the capability to say whether a value is one of a possible set of values.

Variations of an enum are namespaced under its identifier and we use `::` to separate the two:

```rust
enum IpAddrKind {
    V4,
    v6,
}


let four = IpAddrKind::V4;
let four = IpAddrKind::V6;
```

We can then embed data in each enum variant like so:

```rust
enum IpAddrKind {
    V4(String),
    V6(String),
}

let home = IpAddrKind::V4(String::from("127.0.0.1"));
let loopback = IpAddrKind::V6(String::from("::1"));
```

This way there's no need for an additional struct to hold the data.

Another benefit of storing data in enums is that the underlying type signature of the data doesn't have to be the same across variants:

```rust
enum IpAddrKind {
    V4(u8, u8, u8, u8),
    V6(String),
}
```

But you don't have to stop here; you can also embed structs and even enums within enums. Additionally, you can define methods on enums using the same `impl` keyword.

## Option enum
Defined in the standard library. An option is simply something or nothing. Like a unit in `hoon`.

Rust does not have `null` as a concept; but rather has an enum that allows you to encode this concept if you want: the enum is `Option<T>`, defined as:

```rust
enum Option {
    None,
    Some<T>,
}
```

It's so useful that it's included in the prelude. You can use Some and None without the Option prefix.

Just like with `hoon` units, you need to "strip the unit" in order to operate on the underlying data as the static type system recognizes the `Option<T>` type and `T` to be two separate types. To do this, check out the methods available for `Option<T>` in the documentation: https://doc.rust-lang.org/std/option/enum.Option.html.

Using `match` will come in handy to separate code blocks that operate on the data depending on which _option_ is present:

## Match
Allows you to match a pattern to then take that route to some computation. Patterns can be made up of literal values, variable names, wildcards, and many other things.

You match on _arms_ which resolves to some code, separated by `=>`. Each arm is separated by the next with a `,`.

Your code can either be a single line, or encased in `{}` if multiple.

Combining match and enums is useful in many situations. You’ll see this pattern a lot in Rust code: match against an enum, bind a variable to the data inside, and then execute code based on it.

`other` is a catch-all arm which can be used at the end of the arms list to direct all other options that aren't explicitly listed before it. E.g.

```rust
let dice_roll = 9;
match dice_roll {
    3 => add_fancy_hat(),
    7 => remove_fancy_hat(),
    other => move_player(other),
}

fn add_fancy_hat() {}
fn remove_fancy_hat() {}
fn move_player(num_spaces: u8) {}
```

Alternatively, if you don't want to use the catch-all value, you can toss it with `_` instead of `other`.

```rust
let dice_roll = 9;
match dice_roll {
    3 => add_fancy_hat(),
    7 => remove_fancy_hat(),
    _ => (),
}

fn add_fancy_hat() {}
fn remove_fancy_hat() {}
```

# Managing growing projects
Rust has module systems to help you organize your code.

They include:
- Packages: A Cargo feature that lets you build, test, and share crates
- Crates: A tree of modules that produces a library or executable
- Modules and use: Let you control the organization, scope, and privacy of paths
- Paths: A way of naming an item, such as a struct, function, or module

## Packages and crates
 A crate is the smallest amount of code that the Rust compiler considers at a time. They can come in one of two forms: a library crate or binary crate. We've only seen binary crates so far: continaing a `main()` program entry point and other source files that compile to a single binary.

Library crates don't have `main()` function and they don't compile to a binary; instead they define functionality intended to be used with other projects. In practice most Rust programmers refer to 'crate' when they mean library. For example, `crates/nockapp` is a library crate because while it has many Rust files, there is no `main.rs` file; only a `lib.rs` file in `src/`.

You can create a library crate by running: `cargo new <crate-name> --lib`. Whereas running this without the `--lib` flag would create a binary crate by default.

A package is a bundle of one or more crates that provides a set of functionality. Cargo.toml file is included with the package to describe how to build the crates.

A package can contain as many binary crates as you'd like, but only one library crate. There must be one crate, whether binary or library.

If a package contains src/main.rs and src/lib.rs, it has two crates: a binary and a library, both with the same name as the package. A package can have multiple binary crates by placing files in the src/bin directory: each file will be a separate binary crate.

These files (`main.rs` and `lib.rs`) are called _crate roots_ because the compiler hunts for them first, and the contents of either form a module named `crate` at the root of the crate's module structure, known as the _module tree_.

An exmaple:

```
crate
 └── front_of_house
     ├── hosting
     │   ├── add_to_waitlist
     │   └── seat_at_table
     └── serving
         ├── take_order
         ├── serve_order
         └── take_payment
```

## Modules
`use` is the keyword that brings a path into scope and `pub` is the keyword to make items public.

Once a module is a part of your crate, you can refer to code in that module from anywhere else in that same crate, as long as the privacy rules allow, suing the path to the code. It's kind of like a namespace: `crate::garden::vegetables::Asparagus`.

The `use` keyword creates shortcuts to items to reduce repetition of long paths. E.g. by prepending the path to Asparagus above with `use` you can thereafter just refer to `Asparagus`.

`pub mod` is used to make a module public. E.g. by including something like `pub mod garden` you're telling the compiler to inclue the code it finds in `src/garden.rs`.

Modules let us control the privacy of code within them, because by default they're private. By making internal module code public you're allowing other code to use and begin to rely on them.

Modules are declared with `mod` and can be nested within other modules and/or contain functions, structs, enums, constants, traits, etc.

With modules we can group related definitions together an name why they're related.

Here's an example implementing a resturant:

```rust
mod front_of_house {
    mod hosting {
        fn add_to_waitlist() {}
        fn seat_to_table() {}
    }

    mod serving {
        fn take_order() {}
        fn serve_order() {}
        fn take_payment() {}
    }
}
```

*See module tree of how these fit into the overall structure above.

Just like directories in a filesystem, you use modules to organize your code. And just like files in a directory, we need a way to find our modules.

## Paths
Just like navigating a filesystem, you use a path to navigate a module tree. In a call to a function, you need to know its path.

A path can take two forms:

- An absolute path is the full path starting from a crate root; for code from an external crate, the absolute path begins with the crate name, and for code from the current crate, it starts with the literal crate.
- A relative path starts from the current module and uses self, super, or an identifier in the current module.

Path identifiers are separated by `::`.

It's best practice to use absolute paths to retain isolation, reducing the amount of revisions needed as you make changes to paths.

### Public vs. private modules

Parent modules cannot use functions, structs, etc from child modules, unless they're public. By default they're private. This is a deliberate design decision in Rust to avoid external code breaking as a result of easily depending on inner module code; you have to explicitly make this connection, forcing you to think about what you should expose and shouldn't.

You can make a module public with the `pub` keyword. However, making a module public doesn't mean its contents will be public; you have to explicitly state which parts of the module should be public.

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

pub fn eat_at_restaurant() {
    // Absolute path
    crate::front_of_house::hosting::add_to_waitlist();

    // Relative path
    front_of_house::hosting::add_to_waitlist();
}
```

`eat_at_resturant` can acceess `add_to_waitlist` because the funtion and its parent module `hosting` are public and the top-parent module `front_of_house` (while not explicitly stated as public), is a sibling module of `eat_at_resturant` so has access. However, to have other modules outside this crate access `front_of_house` you'd have to explicitly make it public, like `eat_at_resturant`.

These public modules make up your API, particularly in the context of a library crate.

Instead of typing out the full relative path you can use `super` (like `..` in C) to jump out to the parent module to call an item.

```rust
fn deliver_order() {}

mod back_of_house {
    fn fix_incorrect_order() {
        cook_order();
        super::deliver_order();
    }

    fn cook_order() {}
}
```

Making a struct public doesn't automatically make the fields public. These must be granularly made public. However, making an enum public makes all its variants public.

#### Best Practices for Packages with a Binary and a Library
> We mentioned that a package can contain both a src/main.rs binary crate root as well as a src/lib.rs library crate root, and both crates will have the package name by default. Typically, packages with this pattern of containing both a library and a binary crate will have just enough code in the binary crate to start an executable that calls code defined in the library crate. This lets other projects benefit from the most functionality that the package provides because the library crate’s code can be shared.

> The module tree should be defined in src/lib.rs. Then, any public items can be used in the binary crate by starting paths with the name of the package. The binary crate becomes a user of the library crate just like a completely external crate would use the library crate: it can only use the public API. This helps you design a good API; not only are you the author, you’re also a client!

## Using `use`
`use` allows you to state the path to a module once so you can then call the items at that path without having to specify each part of the path every time you make a call.

```rust
mod front_of_house {
    pub mod hosting {
        pub fn add_to_waitlist() {}
    }
}

use crate::front_of_house::hosting;

pub fn eat_at_resturant {
    hosting::add_to_waitlist();
}
```

This is similar to creating a symbolic link in the filesystem. In the example above, `hosting` is now in-scope.

However, `use` only creates a shortcut for the particular scope in which the `use` occurs. If the `eat_at_resturant` function was defined within a different module, `hosting` would not be in scope. I.e. the `use` shortcut needs to be _within_ the context of a module in order to place the contents at the path in scope.

You'll notice that in the example above we still had to call `add_to_waitlist`'s parent module `hosting`. This is considered the "idomatic" way of calling functions in rust. You could get rid of it by specifying the function name in the `use` shortcut (`use crate::front_of_house::hosting::add_to_waitlist;`) which would allow you to then only refer to the function name, but this is bad practice because then it appears that `add_to_waitlist` is a local, rather than "foreign" function. Alternatively, it's good practice to do this for structs, enums, and other items.

```rust
use std::collections::HashMap;

fn main() {
    let mut map = HashMap::new();
    map.insert(1, 2);
}
```

The exception to this is if we're bringing in two items with the same name into scope with `use` statements, becuase Rust doesn't allow that.

```rust
use std::fmt;
use std::io;

fn function1() -> fmt::Result {
    // --snip--
}

fn function2() -> io::Result<()> {
    // --snip--
}
```

Alterntatively, you can alias one of these names with `as`.

```rust
use std::fmt::Result;
use std::io::Result as IoResult;

fn function1() -> Result {
    // --snip--
}

fn function2() -> IoResult<()> {
    // --snip--
}
```

Note that to use the standard library, you do need to pull it into scope - it's not there by default because it's a package (albiet that comes with Rust) like all others.

### Nested `use` paths
Instead of defining each path by line, if items are coming from the same module or crate, you can trunkate into one line by specifying the common part of the path followed by `::` and `{}` around the parts taht differ.

```rust
use std::{fmt::Result, io::Result as IoResult};
// or
use std::io::{self, Write};
```

### The Glob operator
If we'd prefer to bring in all public items defined at a path into scope, we can use the glob operator `*`.

```rust
use std::collections::*;
```

Be careful with this though because as code changes, this may cause compile errors as you have not granularly specified which parts "work" with the code these other modules are interfacing with. It's best used to pull everything into a test module.

## Summary
Rust lets you split a package into multiple crates and a crate into modules so you can refer to items defined in one module from another module.


# Common collections
Collections are a series of useful data structures that exists within the standard library. Unlike build-in types like arrays and tuples, the data that these collections point to are stored on the heap.

A few data types are covered in the book (vectors, strings, and hash maps), but for a full index, see here: https://doc.rust-lang.org/std/collections/index.html


# Errors
There are two types of errors in Rust:
- Recoverable: will keep the program running, but notify the user (i.e. couldn't write to or find a file)
- Unrecoverable: indicated with `panic!` which will hault the program due to critical nature (i.e. running out of memory, etc.)

## Unrecoverable errors with panic!
Rust has the `panic!` macro to help you handle these kinds of errors. Certain types of operations will automatically call a `panic!` - like trying to access an item past the end of an array) - or you can call it manually.

By default, these panics will print a failure message, unwind, clean up the stack, and quit.

Unwinding the Stack or Aborting in Response to a Panic
By default, when a panic occurs the program starts unwinding, which means Rust walks back up the stack and cleans up the data from each function it encounters. However, walking back and cleaning up is a lot of work. Rust, therefore, allows you to choose the alternative of immediately aborting, which ends the program without cleaning up.

Memory that the program was using will then need to be cleaned up by the operating system. If in your project you need to make the resultant binary as small as possible, you can switch from unwinding to aborting upon a panic by adding panic = 'abort' to the appropriate [profile] sections in your Cargo.toml file. For example, if you want to abort on panic in release mode, add this:

```
[profile.release]
panic = 'abort'
```

However, if you chose to use `panic!` you can set the `RUST_BACKTRACE` environment variable to get a backtrace of exactly what happened to cause the error. A backtrace is a list of all the functions that were called that led to this point.

```bash
$ RUST_BACKTRACE=1 cargo run
thread 'main' panicked at src/main.rs:4:6:
index out of bounds: the len is 3 but the index is 99
stack backtrace:
   0: rust_begin_unwind
             at /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/std/src/panicking.rs:692:5
   1: core::panicking::panic_fmt
             at /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/panicking.rs:75:14
   2: core::panicking::panic_bounds_check
             at /rustc/4d91de4e48198da2e33413efdcd9cd2cc0c46688/library/core/src/panicking.rs:273:5
   3: <usize as core::slice::index::SliceIndex<[T]>>::index
             at file:///home/.rustup/toolchains/1.85/lib/rustlib/src/rust/library/core/src/slice/index.rs:274:10
   4: core::slice::index::<impl core::ops::index::Index<I> for [T]>::index
             at file:///home/.rustup/toolchains/1.85/lib/rustlib/src/rust/library/core/src/slice/index.rs:16:9
   5: <alloc::vec::Vec<T,A> as core::ops::index::Index<I>>::index
             at file:///home/.rustup/toolchains/1.85/lib/rustlib/src/rust/library/alloc/src/vec/mod.rs:3361:9
   6: panic::main
             at ./src/main.rs:4:6  # < our panic happens here!
   7: core::ops::function::FnOnce::call_once
             at file:///home/.rustup/toolchains/1.85/lib/rustlib/src/rust/library/core/src/ops/function.rs:250:5
note: Some details are omitted, run with `RUST_BACKTRACE=full` for a verbose backtrace.
```

As you can see the panic happens at the 6th call; line 4:6 from src/main.rs.

## Recoverable errors with Result
However, most errors aren't serious enough to have to force a program to stop entirely. For this we can use the `Result` enum.

```rust
enum Result<T, E> {
    Ok(T),
    Err(E),
}
```

For example, when attempting to open a file with `File::open`, it produces a `Result`:

```rust
use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hello.txt");
}
```

Then we can handle the Result based on the variant:

```rust
use std::fs::File;

fn main() {
    let greeting_file_result = File::open("hello.txt");

    let greeting_file = match greeting_file_result {
        Ok(file) => file,
        Err(error) => panic!("Problem opening the file: {error:?}",
    };
}
```

Note that, like `Option<T>`, `Result<T, E>` is a part of the prelude so we don't have to specify `Result::` as a part of the match arms.

You can go further than this by branching on the error to produce more granular actions based on the result.

### Proprogating errors
If some other function calls your function, you can propogate the error upward to the caller so they can do something with it.

```rust
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let username_file_result = File::open("hello.txt");

    let mut username_file = match username_file_result {
        Ok(file) => file,
        Err(e) => return Err(e),
    };

    let mut username = String::new();

    match username_file.read_to_string(&mut username) {
        Ok(_) => Ok(username),
        Err(e) => Err(e),
    }
}
```

However, this example is a verbose way of error propogation. You can use the `?` shortcut for a more practical implementation:

```rust
use std::fs::File;
use std::io::{self, Read};

fn read_username_from_file() -> Result<String, io::Error> {
    let mut username_file = File::open("hello.txt")?; // if Result is Ok, it'll coninue, otherwise if Err it'll hault and output the error
    let mut username = String::new();
    username_file.read_to_string(&mut username)?;
    Ok(username)
}
```

Alternatively, you could just use the `fs::read_to_string` function from the standard library. This is present because reading a file into a string is a fairly common operation.

```rust
use std::fs;
use std::io;

fn read_username_from_file() -> Result<String, io::Error> {
    fs::read_to_string("hello.txt")
}
```

The `?` operator can also be used to produce an `Option<T>` type. However, of course, the Option type produces either `Some<T>` or `None` instead of `Ok<T>` and `Err<E>`.

```rust
fn last_char_of_first_line(text: &str) -> Option<char> {
    text.lines().next()?.chars().last() // methods on the string slice
}
```

Note that you can produce a `Result<T, E>` from `main`, but since this is the entry and exit point of a program there are some particularities:
- The error type requires the `Box<dyn Error>` type (a trait object), covered in chapter 18.
- The executable will produce a value of 0 if `main` returns `Ok(())` as the `Result`, and a non-zero value if it returns an `Err`. This is an obvious C convention.

There are other types the `main` function can return, but check the ExitCodes in the documentation for more info: https://doc.rust-lang.org/std/process/trait.Termination.html

## When to panic! and when not to
Returning `Result` is a good default choice because you then have further information about the error. You can always call `panic!` on the error, or a particular error and attempt to recover in other scenarios.

However in situations such as examples, prototype code, and tests, it's more appropraite to write code that panics instead of returning result. In these scenarios including error handling can cause unnecessary overhead, making it better to return later and implement robust error handling with `Result`. Similarly, `unwrap` and `expect` methods are very handy when prototyping because they make clear markers for where you need to implement error handling later on.

### Guidelines for error handling
You do want your code to panic when it's possible that it could end up in a bad state. However, when failure is expected, it's more appropriate to return a `Result`.

> When your code performs an operation that could put a user at risk if it’s called using invalid values, your code should verify the values are valid first and panic if the values aren’t valid. This is mostly for safety reasons: attempting to operate on invalid data can expose your code to vulnerabilities. This is the main reason the standard library will call panic! if you attempt an out-of-bounds memory access: trying to access memory that doesn’t belong to the current data structure is a common security problem. Functions often have contracts: their behavior is only guaranteed if the inputs meet particular requirements. Panicking when the contract is violated makes sense because a contract violation always indicates a caller-side bug, and it’s not a kind of error you want the calling code to have to explicitly handle. In fact, there’s no reasonable way for calling code to recover; the calling programmers need to fix the code. Contracts for a function, especially when a violation will cause a panic, should be explained in the API documentation for the function.

Similarly, to reduce the amount of error checking in your code it's good to get in the habit of performing type validations on custom types, where possible. For example:

Instead of implementing the type check within the function, and doing one-off variables, like here:

```rust
    loop {
        // --snip--

        let guess: i32 = match guess.trim().parse() {
            Ok(num) => num,
            Err(_) => continue,
        };

        if guess < 1 || guess > 100 {
            println!("The secret number will be between 1 and 100.");
            continue;
        }

        match guess.cmp(&secret_number) {
            // --snip--
    }
```

Better to simply create a custom struct type for `Guess` that embeds the type validation as a method:

```rust
pub struct Guess {
    value: i32,
}

impl Guess {
    pub fn new(value: i32) -> Guess {
        if value < 1 || value > 100 {
            panic!("Guess value must be between 1 and 100, got {value}.");
        }

        Guess { value }
    }

    pub fn value(&self) -> i32 {
        self.value
    }
}
```

So when creating a new `Guess` you call `Guess.new()` which validates that the number be between 1 and 100 automatically. If the `i32` number passes the validation it's stored in `Guess { value }` so it can be accessed via a _getter_ function with `value()`.

# Generic types, Traits, and Lifetimes
Generics refers to abstract stand-ins for concrete types or other properies (e.g. `Result<T, E>`, `Option<T>`, or `HashMap<K, V>`), opposed to something like `i32` or `String`.

Like these foundational generic types, you can create your own.

Traits are used to define behavior in a generic way. And Lifetimes is a variety of generics that give the compiler information about how references relate to each other.

The core benefit of using generics is code deduplication. With generics you can replace specific types with a placeholder that represents multiple types.

For example, here's an instance of using generics on a function:
```rust
fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let mut largest = &number_list[0];

    for number in &number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("The largest number is {largest}");

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let mut largest = &number_list[0];

    for number in &number_list {
        if number > largest {
            largest = number;
        }
    }

    println!("The largest number is {largest}");
}
```

No need to have two of the same functions, just make a generic one to pass the slices into:

```rust
fn largest(list: &[i32]) -> &i32 {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}

fn main() {
    let number_list = vec![34, 50, 25, 100, 65];

    let result = largest(&number_list);
    println!("The largest number is {result}");

    let number_list = vec![102, 34, 6000, 89, 54, 2, 43, 8];

    let result = largest(&number_list);
    println!("The largest number is {result}");
}
```

To parameterize a type in a function, you need to name the type parameter. You can use any identifier as a type parameter name, but by convention Rust type parameters are short, often just one letter, and CamelCase. `T` is more often than not used.

Then, you declare the type parameter in the function signature in `<>`: `fn largest<T>(list: &[T]) -> &T {`

However, you'll notice that in the function below it's not clear that this type can/should be compared like it is. What if the parameter type was an enum or string? This is where Traits come in.

In this example, we port in the `PartialOrd` trait to enable parameter type `T` to be compared as a type that is ordered.

```rust
fn largest<T: std::cmp::PartialOrd>(list: &[T]) -> &T {
    let mut largest = &list[0];

    for item in list {
        if item > largest {
            largest = item;
        }
    }

    largest
}
```

You can also use generics in structs:

```rust
struct Point<T> {
    x: T,
    y: T,
}
```

Just like with functions you need to define the type `T` within `<>` after the name of the struct.

Of course, type `T` is one type so both `x` and `y` must be of the same type.


```rust
fn main() {
    let integer = Point { x: 5, y: 10 };
    let float = Point { x: 1.0, y: 4.0 };
}
```

However, it's possible to have multiple type parameters:

```rust
struct Point<T, U> {
    x: T,
    y: U,
}

fn main() {
    let both_integer = Point { x: 5, y: 10 };
    let both_float = Point { x: 1.0, y: 4.0 };
    let integer_and_float = Point { x: 5, y: 4.0 };
}
```

Just like `Result<T, E>`. And, you can include as many generic types as you want, but generally want to keep it limited to a few per function or struct else you risk legibility.

While skipped here, you can also use generics with Enums and methods: https://doc.rust-lang.org/book/ch10-01-syntax.html

## Performance consideration
There's no performance difference between generic and concrete types.

> Rust accomplishes this by performing monomorphization of the code using generics at compile time. Monomorphization is the process of turning generic code into specific code by filling in the concrete types that are used when compiled. In this process, the compiler does the opposite of the steps we used to create the generic function in Listing 10-5: the compiler looks at all the places where generic code is called and generates code for the concrete types the generic code is called with.

However, without monomorphization generic types _would_ be slower during runtime as there would be overhead in replacing their types with ones that are concrete.

Example:
```rust
let integer = Some(5);
let float = Some(5.0);
```

> When Rust compiles this code, it performs monomorphization. During that process, the compiler reads the values that have been used in Option<T> instances and identifies two kinds of Option<T>: one is i32 and the other is f64. As such, it expands the generic definition of Option<T> into two definitions specialized to i32 and f64, thereby replacing the generic definition with the specific ones.


## Traits: defining shared behavior
As mentioned above a trait defines the functionality a particular type has and can share with other types.

Defining a trait involves naming it along with including what are essentially functions signatures, but techincally called methods that end in `;` to indicate what is produced as a result of calling that trait's method.

```rust
pub trait Summary {
    fn summarize(&self) -> String;
}
```

You can have any number of methods per trait.

Then to implement the trait, you follow the same method signature but actuall implement how the type is formed:

You'll notice implementing a trait looks a lot like a method implementation:

```rust
pub struct NewsArticle {
    pub headline: String,
    pub location: String,
    pub author: String,
    pub content: String,
}

impl Summary for NewsArticle {
    fn summarize(&self) -> String {
        format!("{}, by {} ({})", self.headline, self.author, self.location)
    }
}
```

Within the impl block we put the method signatures that the trait definition has defined.

Now users of this library can implement the trait on `NewsArticle` by calling the trait just like they would a method.

However, if you want, you can include a default trait implementation that can be called the same way. You can mix and match - including implemented trait methods and not.

```rust
pub trait Summary {
    fn summarize_author(&self) -> String;

    fn summarize(&self) -> String {
        format!("(Read more from {}...)", self.summarize_author())
    }
}
```

See here for more on traits: https://doc.rust-lang.org/book/ch10-02-traits.html#traits-as-parameters


## Validating references with Lifetimes
Rather than ensuring a type has the behavior we want, lifetimes ensure that references are valid as long as we need them to be.

On thing we skipped over when covering references originally is that every reference has a _lifetime_, which is a scope for which that reference is valid.

Most of the time lifetimes are implicit and inferred, just like most types are inferred. This is a novel concept compared to other programming languages.

The main aim with lifetimes is to prevent dangling references which cause a program to reference data other than the data it's intended to reference.

```rust
fn main() {
    let r;

    {
        let x = 5;
        r = &x;
          // ^ borrowed value doesn't 'live long enough'
    }

    println!("r: {r}");
}
```

> The error message says that the variable x “does not live long enough.” The reason is that x will be out of scope when the inner scope ends on line 7. But r is still valid for the outer scope; because its scope is larger, we say that it “lives longer.” If Rust allowed this code to work, r would be referencing memory that was deallocated when x went out of scope, and anything we tried to do with r wouldn’t work correctly. So how does Rust determine that this code is invalid? It uses a borrow checker.

Here's a visual of the lifetime scope for both r and x:

```rust
fn main() {
    let r;                // ---------+-- 'a
                          //          |
    {                     //          |
        let x = 5;        // -+-- 'b  |
        r = &x;           //  |       |
    }                     // -+       |
                          //          |
    println!("r: {r}");   //          |
}                         // ---------+
```

To fix:

```rust
fn main() {
    let x = 5;            // ----------+-- 'b
                          //           |
    let r = &x;           // --+-- 'a  |
                          //   |       |
    println!("r: {r}");   //   |       |
                          // --+       |
}                         // ----------+
```

### Lifetime annotations
Annotations describe the relationship of the lifetimes to multiple references to each other without affecting the lifetimes. Just as functions can accept any type when the signature specifies a generic type parameter, functions can accept references with any lifetime by specifying a generic lifetime parameter.

The names of a lifetime parameter must start with `'` and are usually all lowercase and very short like generic types.

Conventionally, most use `'a` for the first lifetime annotation. E.g.

```rust
&i32  // a reference
&'a i32 // a reference with an explicit lifetime
&'a mut i32 // a mutable reference with an explicit lifetime
```

In function signatures, lifetime annotations look similar to generic type parameter function signatures:

```rust
fn longest<'a>(x: &'a str, y: &'a str) -> &'a str {
    if x.len() > y.len() { x } else { y }
}
```

> The function signature now tells Rust that for some lifetime 'a, the function takes two parameters, both of which are string slices that live at least as long as lifetime 'a. The function signature also tells Rust that the string slice returned from the function will live at least as long as lifetime 'a. In practice, it means that the lifetime of the reference returned by the longest function is the same as the smaller of the lifetimes of the values referred to by the function arguments. These relationships are what we want Rust to use when analyzing this code.
>
> Remember, when we specify the lifetime parameters in this function signature, we’re not changing the lifetimes of any values passed in or returned. Rather, we’re specifying that the borrow checker should reject any values that don’t adhere to these constraints. Note that the longest function doesn’t need to know exactly how long x and y will live, only that some scope can be substituted for 'a that will satisfy this signature.


The lifetime parameter for the return type must have an annotation in one or moe of the function parameters in order to compile.

### Lifetime annotations in structs
We can define structs to hold references, but in that case we would need to add a lifetime annotation on every reference in the struct's definition.

```rust
struct ImportantExcerpt<'a> {
    part: &'a str,
}

fn main() {
    let novel = String::from("Call me Sage...");
    let first_sentence = novel.split('.').next().unwrap();
    let ImportantExcerpt {
        part: first_sentence;
    };
}
```

