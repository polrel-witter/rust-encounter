# Updating
`rustup` is the general command to install, update, etc. e.g. `rustup update` & `rustup self uninstall`.

Local Rust documentation can be found by running `rustup doc`. This will open in your browser.

# Naming
Use snake_case for file names.



# Anatomy of a rust program
## Construction
The `main()` function is the program entry point just like C programs. It's always the first code that runs in every executable Rust program.

So with a simple program such as this:
```rust
fn main() {
    println!("hello world");
}
```

The `!` at the end of `println` indicates it's running as a macro. Will learn more about this later, but for now just note macros run by different rules than functions.

Additionally, most lines in Rust code ends with `;`.

## Compiling and running
These are separate steps; like with C programs after compiling there's an executable of the program that you'll run.

Rust is an "ahead-of-time compiled language" meaning you can build a program and send the executable for someone else to run (even without having Rust installed). Alternatively, in languages like Ruby, Javascript, and Python they'd need the respective languages installed in order to run the program, but compilation and running the program happens in one command.

# Cargo!
Rust's build system and package manager.

Cargo comes installed with Rust; `cargo --version`.

To create a cargo package run: `cargo new <project_name>`. This will generate a "binary application package" - a directory along with a Cargo.toml, .gitignore (if one hasn't already been initalized), and a `src/main.rs` file.

The `Cargo.toml` is Rust's config format. Packages (source code files) in Rust are referred to as crates. Cargo expects your source files to live in `src/`. This is why `main.rs` is auto-placed here. The top-level directory is for any files unrelated to code: i.e. README, config, license info, etc.

If you already have a directory, not generated by `cargo`, you can run `cargo init` to build it internally.

## Buildling and runing a cargo project
Instead of compiling your program manually - this would be complicated if you have multiple source files - you can simply run `cargo build` to compile the crate.

This will create an executable file in `target/debug/<project_name>` within your project directory. You can run the executable with `./target/debug/<project_name>`.

By building via cargo, you'll also have a `Cargo.lock` file in the top-level directory. This file keeps track of the exact versions of your deps in your project; cargo manages the contents of this file for you.

Alterntatively, you can more simply build and run the program in one swoop with `cargo run`.

Then to check code to make sure it compiles without generating an exectuable, run: `cargo check`. If you don't need to run the program - this is a must faster process as it doesn't ahve to build the executable. It's highly recommended to use this if you check your work as you go along, as you'll save a lot of time in the long run.

## Releasing cargo
`cargo build --release` to compile to an executable with optimizations. It'll also create an executable in `target/release` instead of `target/debug`. Notably, building for release takes longer because Rust is optimizing it so it's not recommended to use this regularly while in the development phase.


# Creating a larger program
Importing deps from the standard library can be done by  using `use` keyword at the top of your program. Rust has a set of items defined in the std library that it brings into the scope of every program, called the _prelude_; found here: https://doc.rust-lang.org/std/prelude/index.html. However, if what you need is not listed in here,  you'll need to manually import it. This is why the `println!` macro didn't need an import module earlier.

## Storing values and variables
You can declare variables with `let`. Variables are immutable by default, meaning once we give the variable a value it won't change (more about this in Ch. 3). However, to make a valuable mutable we add `mut` before the variable name:
```rust
let apples = 5; // immutable
let mut apples = 5; // mutable
```

You can associate functions to specific types (e.g. `String::new();`) which is kind of like a class method; you can apply some inherent function on the associated type. In the example, a new, empty `String` is generated.

`&` indicates that an argument is a _reference_, which gives you a way to let multiple parts of your code access one piece of data without needing to copy that data into memory multiple times. Like variables, references are immutable by default. Hence you'd need to write `&mut apples` instead of just `&apples` to make it mutable. More on references in chapter 4.

If a function produces a result - something like Err or Ok - you'll need to handle those cases with `.expect` which allows you to define which options produce what to the user; an error message or a note indicating success. Like C programs you have to handle these, otherwise you'll get a warning.

When printing the value of a variable, you can do so by simply placing the variable name in `{}` braces.

## Using crates
There's a difference between a binary crate - indented to be executed on its own - and a library crate to be used in other programs.

Before referencing a crate in your program, you have to add it as a dependency in your Cargo.toml file. E.g.
```rust
[dependencies]
rand = "0.8.5"
```

Importantly, if you were to update this dependency list, Cargo will only update up to 9.0 (if any beyond that exist). To retreive anything above 9.0 you'd need to note it explicitly: "0.9.0".

Cargo then fetches the latest versions of what we need from the registry, which is a copy of data from https://crates.io (the rust open source ecosystem).

Cargo will only use the versions of deps you specified until you indicate otherwise. This aids in protecting against dependency hell. E.g. lets say a new version of `rand` comes out, containing an important bug fix, but it'd cause your code to break  - this wouldn't be ideal. This is where the `Cargo.lock` file comes in; when Cargo builds your project, it notes the dependency versions in the `Cargo.lock` file which is quickly referenced later when you go to build the program again. This is important for reproducable builds so you want to include this in source like the rest of your code.

You can update your entire dependency list and the associated `Cargo.lock` versions by running `cargo update` in the project folder.

Run `cargo doc --open` to auto-build documentation of your dependency lists and view it in your local browser.

# Common programming concepts
## Variables and mutability
By default variables are immutable, as noted previously; this is one advantage with Rust, enhancing code safety.

Having immutable variables by default makes reasoning about variables across codebases much easier.

## Constants
Not just immutable by default; they're always immutable. Use `const` instead of `let` and the type keyword _must_ be annotated. They can also be declared in any scope, including global scope.

The last characteristic is that constants can be only set to a constant expression, not the result of a value that could only be computed at runtime. And they must be in all uppercase.

E.g. `const THREE_HOURS_IN_SECONDS: u32 = 60 * 60 * 3;`

They're of course useful in a global context, allowing many parts of the program to know about them. It also makes updating constant values much easier than reinstantiating immutable variables peppered throughout the codebase.

## Shadowing
Means you can declare a new variable with the same name as a previous variable; i.e. the first variable is _shadowed_ by the second.

```rust
fn main() {
    let x = 5;

    let x = x + 1;

    {
        let x = x * 2;
        println!("The value of x in the inner scope is: {x}");
    }

    println!("The value of x is: {x}");
}
```

Output will be:
```
The value of x in the inner scope is: 12
The value of x is: 6
```

Because the inner scope leverages x, but since it's separated by braces after it executes, x will remain 6 as assigned with `let x = x + 1;`

Also note that shadowing is possible because we're using the `let` keyword to reassign x. This is of course different from using `mut` because with `mut` you don't have to redefine with `let`; the value is merely mutated.

The utlity of shadowing allows to refrain from comming up with different names for the same variables.

## Data types
Every value in rust is of a certain data type. Rust is a statically typed language, meaning it _must_ know the types of all variables at _compile time_.

### Scalar types
Represents a single value. Rust primarily has 4:
- integers
- floating-point numbers
- booleans
- characters

**Integer**
A number without a fractional component. Here are Rusts types:
Length                  Signed        Unsigned
8-bit                   i8            u8
16-bit                  i16           ...
32-bit                  ...
64-bit
128-bit
architecture dependent  isize

Number literals can use `_` as a visual separator to make numbers that would otherwise have a `.` easier to read; but both 1000 and 1_000 are handled the same way.

Practially, if you're unsure of which integer types to use it's fruitful to just go with Rusts' defaults: e.g. i32.

_Integer overflow_ occurs when you attempt to assign a value that's outside the length of the variable type. eg. assigning a value of say 271 to an `u8` integer which has the range of 0 to 255. This will cause your program to _panic_ at runtime, but the compiler should catch it.

**Boolean**
One byte in size, specified using `bool`; `let f: bool = false;`

**Character**
`char` is the most primitive alphabetic type. Here are some example declarations:
```rust
fn main() {
    let c = 'z';
    let z: char = 'Z';
    let heart_eyed_cat = 'ðŸ˜»';
}
```

Characters are four bytes in size and represents a Unicode scalar value, which means it can represent a lot more than just ASCII.

### Compound types
Group multiple values into one type; rust has two primitive types: tuples and arrays.

**Tuple**
A way to group a number of values with a variety of types into one compound type. They have a fixed length; once declared they cannot grow or shrink in size.

E.g.
```rust
let main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
```

To access a value in the tuple you can either _destructure_ it by assigning each value in the tuple a variable then calling the variable or by referencing the value directly with a period `.` followed by the index of the value:

```rust
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
```

**Array**
Unlike a tuple, every element of an array must have the same type. Arrays also have fixed lengths.

They're written as comma-separated lists inside square brackets: `let a = [1, 2, 3, 4, 5];`

An array's cousin, a Vector, is more flexible as it can grow and shrink in size. It's able to do this because its contents exist on the heap; rather than the stack which is where the contents of an array live.

The trade-offs:
Arrays sacrifice flexibility for guaranteed performance and compile-time guarantees. If you know the size won't change, arrays eliminate an entire class of runtime overhead.

It's about choosing the right tool: arrays for speed and predictability, vectors for flexibility.

You write an array's type like so: `let a: [i32; 5] = [1, 2, 3, 4, 5];` where `i32` is the type of each element

You can access elements of anrray using indexing:
```rust
fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
```

## Functions
Declared with `fn` and names are written in snake_case, as with file names and variables.

Rust doesn't care about where you've defined your functions, only that they're defined somewhere within the scope seen by the caller.

In function signatures you must declare the type of each parameter. Separate multiple params with commas: `(value: i32, unit_label: char)`

Function bodies are construted with a series of statements optionally ending in an expression, defined as:
- Statements: instructions that perform some action and do not return a value
- Expressions: evaluate to a resultant value

Expressions do not include ending semicolons:
```rust
let y = {
    let x = 3;
    x + 1
};
```

If you add a semicolon to the end it'll turn into a statement, not returning a value.

### Returning values
Functions can return values to those that called them. You can't name return values, but you declare they're type with an arrow `->`. You can return early from a function using the `return` keyword and specifying a value.

```rust
fn five() -> i32 {
    5
}

fn main() {
    let x = five();

    println!("The value of x is : {x}");
}
```

## Control flow
### If expressions
Blocks of code associated with the conditions in `if` expressions are called _arms_, just like arms in a `match` expression. We can optionally include an `else` condition.

Because `if` is an expression we can use it on the right side of a `let` statement:
```rust
fn main() {
    let condition = true;
    let number = if condition { 5 } else { 6 };

    println!("The value of number is: {number}");
}
```

Note that variables in an if statement must have a single type. So in the above example we couldn't replace 6 with `"six"`.

### Loops
`break` terminates the loop while `continue` will tell the program to skip over any remaining code in this iteration and go to the next.

You can use `break` to return a value as well:
```rust
fn main() {
    let mut counter = 0;

    let result = loop {
        counter += 1;

        if counter == 10 {
            break counter * 2;
        }
    };

    println!("Result is {result}");
}
```

Alternatively, you can also use `return` to exit a loop an produce some result.

You can use _loop labels_ to address a specific loop (if you have more than one nested), used with `break` and `continue` like so:
```rust
fn main() {
    let mut count = 0;
    'counting_up: loop {
        println!("count = {count}");
        let mut remaining = 10;

        loop {
            println!("remaining = {remaining}");
            if remaining == 9 {
                break;
            }
            if count == 2 {
                break 'counting_up;
            }
            remaining -= 1;
        }

        count += 1
    }
    println!("End count = {count}");
}
```

Use `while` to loop while a condition is true.

Helpful to use a `for` loop for iterating over an array (more efficent than usuing `while`):
```rust
fn main() {
    let a = [10, 20, 30, 40, 50];

    for element in a {
        println!("the value is: {element}");
    }
}
```

# Ownership
A unique feature in Rust. It enables memory safety guarantees without needing a garbage collector.

It's a set of rules that governs how a Rust program manages memory. Some languages have garbage collection that regularly looks for no-longer-used memory as the program runs; in other languages, the programmer must explicitly allocate and free the memory. Rust uses a third approach: memory is managed through a system of ownership with a set of rules that the compiler checks. If any of the rules are violated, the program wonâ€™t compile. None of the features of ownership will slow down your program while itâ€™s running.

Ownership forces you to think about the Stack and Heap (what's in memory at any given time). They're both available to your code to use at runtime, but they're sturctured in different ways. The stack stores values in the order it gets them and removes them in the  opposite order (i.e. last-in-first-out). All data stored on the stack must have a known, fixed size. Any data with an unknown size must be stored on the heap, which is less organized.

When you allocate to the heap, you request a certain amount of space. Malloc finds an empty spot in the heap that's big enough, marks it as being in use, then returns a pointer (the address at that location). This is called _allocating_. Because the pointer _to_ the heap is a known, fixed size, you can store the pointer on the stack, but when you need the actual data, you must go to the heap.

The stack is faster because the allocator never has to look for an empty space to store the data; that location is always at the top of the stack. Additionally, accessing data on the heap is slower too because you have to follow a pointer to get there.

The main purpose of ownership is to manage heap data.

## Rules
- Each value in Rust has an _owner_.
- There can only be one owner at a time.
- When the owner goes out of scope, the value will be dropped.

## Variable scope
A variable is valid (in scope) from the point at which it's declared until the end of the current _scope_.

## Memory and allocation
With a data type that has a variable size the memory must be requested from malloc at runtime (opposed to something like a string literal which is hardcoded into the program's exectuable at compile time). We also need a way to return this memory to the allocator when we're done using it.

Most languages have a garbage collector to handle the cleanup. However, these GCs come with serious overhead, reducing performance. Rust takes a different path: the memory is automatically returned once the variable that owns it goes out of scope. Rust calls `drop` when this happens, which happens automatically at the closing curly bracket. E.g.
```rust
{
    let s = String::from("hello"); // s is valid from this point forward as it's allocated to the heap

    // do stuff with s
} // this scope is now over, and s is no longer valid.
```

Similar to subject-oriented programming where what's in scope at any given point is of primary concern.

### Moves
When assigning, say, one string variable to another like in the example below, in Rust terms this is called a move because what's happening under the hood is that `s1` (made up of a pointer, lenght of the data in bytes, and capacity in bytes stored on the Stack) is simply moved to `s2` instead and the `s1` pointer and associated data is invalidated.

In other languages this would be called something like a _shallow copy_ (opposed to a deep copy where the data is physically copied in memory) which makes both variables point at the same data in memory. However, Rust doesn't allow this because without carefully freeing it properly you encounter what's called the _double free_ error, leading to memory corruption which can potentially lead to security vulnerabilities.

Hence it's called a _move_ and not a _copy_. This implies that Rust will never automatically create "deep" copies of your data so any automatic copying can be assumed to be inexpensive in terms of runtime performance.

### Scope and assignment
This _move_ behavior happens with "reassigned" variables, too. For instance:
```rust
let mut s = String::from("hello");
let s = String::from("ahoy");
```

The "hello" assigned to `s` is `drop`ped for `ahoy` instead.

### Cloning
If you want to deep copy the heap data of the String, not just the stack data (pointer, length, and capacity), you can use something called the `clone` method to do so.

This will make a hard copy in the heap and assign it to your variable:
```rust
let s1 = String::from("hellow");
let s2 = s1.clone();
```

### Stack-only copy
Types such as integers that have a known size at compile time are stored entirely on the stack, so copies of the actual values are quick to make. In this example `x` still remains independent of `y` and retains its value: 5.
```rust
let x = 5;
let y = x;
```

This works because integers have a special annotation called the `Copy` trait which applies to other types that are stored on the stack. If a type has the `Copy` trait, variables that use it do not `move`; rather are trivially copied onto the stack, making them still valid after assigning them to another variable.

Others that implement the `Copy` trait contain scalar attributes, meaning they don't require allocation. Some other types that contain this trait:
- Boolean
- Floating point
- Characters
- Tuples, if they also contain types that implement `copy`.

### Ownership and functions
Passing a variable to a function will move or copy it, just as assignment does. However, there's one strange quality that typifies the idea of ownership: if a variable of a non-scalar type (i.e. a String, array, etc.) is passed to another function, that variable goes out of scope. However, types that implement `Copy` do not go out of scope after being passed to another function.

```rust
fn main() {
    let s = String::from("hello"); // s comes into scope

    takes_ownership(s); // s goes out of scope

    let x = 5; // x comes into scope

    makes_copy(x); // x is still in scope after this.
}
```

## References and borrowing
Since variable values basically disappear after passing to a function, and it's common to have to reference that variable later on, Rust has what are called _references_ which allow you to call that data from memory. They're kind of like pointers except that a reference garantees to point to a valid value of a particular type for the life of the reference.

A reference is an address in memory:

```rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1); // reference to s1

    println!("The lenth of {s1} is {len}");
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```

As you can see the `&` indicate a reference and allow you to pass a referance of the data to a different function without passing over ownership of it. The opposite of referencing is dereferencing, with `*`, but we'll cover this later.

When a function merely accepts references rather than actual values there's no need to "pass back" any data to give back ownership because it never had ownership of the data.

The action of creating a reference is called _borrowing_. In line with this, when you pass a reference to a different function you can't modify it; just as variables are immutable by default, so are references.

### Mutable references
Just like a mutable variable, you explicitly state whether you're passing a mutable reference of the underlying value or not:

```rust
fn main() {
    let mut s = String:from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```

However, it's not possible to make multiple mutable references. This prevents data races.

Instead, if you need to refer to a mutable reference more than once, you'll want to section it out of scope before doing so, like:

```rust
let mut s = String::from("hello");

{
    let r1 = &mut s;
} // r1 goes out of scope here, so we can make a new reference without a problem

let r2 = &mut s;
```

## The slice type
String slices are nice to use in scenarios where you're needing to reference "chunks" of elements within a `String`. E.g. instead of having to implement functions that keep track of various indicies and the underlying String itself, you can use String Slices, which look like this:

```rust
let s = String::from("hello world");

let hello = &s[0..5];
let world = &s[6..11];
```

Rather than a reference to the entire string, you can slice it up by refering to specific portions of it. Explicitly, the grammar is `[starting_index..ending_index]`. Starting index is where to start and ending is one more than where to end.

You can also drop the 0 if you're referring to the beginning of a string (e.g. `[..4]`); similarly if your slice includes the last byte of the string, you can drop the trailing number: `[5..]`. And, can finally drop both indicies if you want to take the whole string: `[..]`.

Note: String slice range indices must occur at valid UTF-8 character boundaries. If you attempt to create a string slice in the middle of a multibyte character, your program will exit with an error.

It's also important to note that a string slice _is_ a reference. The type indicating a string slice is `&str`.

E.g.
```rust
fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[..i];
        }
    }

    &s[..]
}
```

A `String` is equivelant to a whole slice of a string so can be passed into a function that accepts a string slice:

```rust
let my_string = String:from("hello world");

let word = first_word(&my_string[..]);
let word = first_word(&my_string);

// It also works for string literals
let my_string_literal = "hello world";

let word = first_word(&my_string_literal[..]);
let word = first_word(my_string_literal);
```

Lastly, slices are not solely specific to strings; they can be applied to a number of other "collections" which will be covered later.


### Moves
When assigning, say, one string variable to another like in the example below, in Rust terms this is called a move because what's happening under the hood is that `s1` (made up of a pointer, lenght of the data in bytes, and capacity in bytes stored on the Stack) is simply moved to `s2` instead and the `s1` pointer and associated data is invalidated.

In other languages this would be called something like a _shallow copy_ (opposed to a deep copy where the data is physically copied in memory) which makes both variables point at the same data in memory. However, Rust doesn't allow this because without carefully freeing it properly you encounter what's called the _double free_ error, leading to memory corruption which can potentially lead to security vulnerabilities.

Hence it's called a _move_ and not a _copy_. This implies that Rust will never automatically create "deep" copies of your data so any automatic copying can be assumed to be inexpensive in terms of runtime performance.

### Scope and assignment
This _move_ behavior happens with "reassigned" variables, too. For instance:
```rust
let mut s = String::from("hello");
let s = String::from("ahoy");
```

The "hello" assigned to `s` is `drop`ped for `ahoy` instead.

### Cloning
If you want to deep copy the heap data of the String, not just the stack data (pointer, length, and capacity), you can use something called the `clone` method to do so.

This will make a hard copy in the heap and assign it to your variable:
```rust
let s1 = String::from("hellow");
let s2 = s1.clone();
```

### Stack-only copy
Types such as integers that have a known size at compile time are stored entirely on the stack, so copies of the actual values are quick to make. In this example `x` still remains independent of `y` and retains its value: 5.
```rust
let x = 5;
let y = x;
```

This works because integers have a special annotation called the `Copy` trait which applies to other types that are stored on the stack. If a type has the `Copy` trait, variables that use it do not `move`; rather are trivially copied onto the stack, making them still valid after assigning them to another variable.

Others that implement the `Copy` trait contain scalar attributes, meaning they don't require allocation. Some other types that contain this trait:
- Boolean
- Floating point
- Characters
- Tuples, if they also contain types that implement `copy`.

### Ownership and functions
Passing a variable to a function will move or copy it, just as assignment does. However, there's one strange quality that typifies the idea of ownership: if a variable of a non-scalar type (i.e. a String, array, etc.) is passed to another function, that variable goes out of scope. However, types that implement `Copy` do not go out of scope after being passed to another function.

```rust
fn main() {
    let s = String::from("hello"); // s comes into scope

    takes_ownership(s); // s goes out of scope

    let x = 5; // x comes into scope

    makes_copy(x); // x is still in scope after this.
}
```

## References and borrowing
Since variable values basically disappear after passing to a function, and it's common to have to reference that variable later on, Rust has what are called _references_ which allow you to call that data from memory. They're kind of like pointers except that a reference garantees to point to a valid value of a particular type for the life of the reference.

A reference is an address in memory:

```rust
fn main() {
    let s1 = String::from("hello");

    let len = calculate_length(&s1); // reference to s1

    println!("The lenth of {s1} is {len}");
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```

As you can see the `&` indicate a reference and allow you to pass a referance of the data to a different function without passing over ownership of it. The opposite of referencing is dereferencing, with `*`, but we'll cover this later.

When a function merely accepts references rather than actual values there's no need to "pass back" any data to give back ownership because it never had ownership of the data.

The action of creating a reference is called _borrowing_. In line with this, when you pass a reference to a different function you can't modify it; just as variables are immutable by default, so are references.

### Mutable references
Just like a mutable variable, you explicitly state whether you're passing a mutable reference of the underlying value or not:

```rust
fn main() {
    let mut s = String:from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```

However, it's not possible to make multiple mutable references. This prevents data races.

Instead, if you need to refer to a mutable reference more than once, you'll want to section it out of scope before doing so, like:

```rust
let mut s = String::from("hello");

{
    let r1 = &mut s;
} // r1 goes out of scope here, so we can make a new reference without a problem

let r2 = &mut s;
```

## The slice type
String slices are nice to use in scenarios where you're needing to reference "chunks" of elements within a `String`. E.g. instead of having to implement functions that keep track of various indicies and the underlying String itself, you can use String Slices, which look like this:

```rust
let s = String::from("hello world");

let hello = &s[0..5];
let world = &s[6..11];
```

Rather than a reference to the entire string, you can slice it up by refering to specific portions of it. Explicitly, the grammar is `[starting_index..ending_index]`. Starting index is where to start and ending is one more than where to end.

You can also drop the 0 if you're referring to the beginning of a string (e.g. `[..4]`); similarly if your slice includes the last byte of the string, you can drop the trailing number: `[5..]`. And, can finally drop both indicies if you want to take the whole string: `[..]`.

Note: String slice range indices must occur at valid UTF-8 character boundaries. If you attempt to create a string slice in the middle of a multibyte character, your program will exit with an error.

It's also important to note that a string slice _is_ a reference. The type indicating a string slice is `&str`.

E.g.
```rust
fn first_word(s: &String) -> &str {
    let bytes = s.as_bytes();

    for (i, &item) in bytes.iter().enumerate() {
        if item == b' ' {
            return &s[..i];
        }
    }

    &s[..]
}
```

A `String` is equivelant to a whole slice of a string so can be passed into a function that accepts a string slice:

```rust
let my_string = String:from("hello world");

let word = first_word(&my_string[..]);
let word = first_word(&my_string);

// It also works for string literals
let my_string_literal = "hello world";

let word = first_word(&my_string_literal[..]);
let word = first_word(my_string_literal);
```

Lastly, slices are not solely specific to strings; they can be applied to a number of other "collections" which will be covered later.

# Structs
## Defining and instantiating
Structs are similar to Tuples although you'll name the different types associated with it, making them more flexible as you don't have to rely on the ordering of the types when interacting with it. You can just reference the various parts by name. These parts are called _fields_.

```rust
struct User {
    active: bool,
    username: String,
    email: String,
    sign_in_count: u64,
}
```

Then to instantiate:
```rust
fn main() {
    let user1 = User {
        active: true,
        username: String::from("someusername"),
        email: String::from("someone@aol.com"),
        sign_in_count: 1,
    };
}
```

Then to access a field in a struct you can use dot `.` notiation: `user1.email`. If you mark the struct instance mutible you can change certain fields by simply calling the "arm". Note that you must make the entire struct mutable; it's not possible to only make parts of it as such.

There's a field init shorthand so you can avoid duplicating the same words:
```rust
fn build_user(email: String, username: String) -> User {
    User {
        active: true,
        username, // rather than username: username,
        email,  // or email: email,
        sign_in_count: 1,
    }
}
```

Similarly, there's an update syntax that allows you to reduce your code:

```rust
let user2 = User {
    email: String::from("another@aol.com"),
    ..user1  // assigns the remaining fields from user1 since they won't change
};
```

This shortcut must come last, but it doesn't matter what order the other fields are in the struct. This update syntax allow uses `=` (assignment) so the data from user1 to user2 would be _moved_; hence these data from user1 would no longer be valid. 

### Tuple structs
You can build tuples similar to structs if you're in a scenario where you need to name the tuple, but don't need field names.

```rust
struct Color(i32, i32, i32);
struct Point(i32, i32, i32);

fn main() {
    let black = Color(0, 0, 0);
    let origin = Point(0, 0, 0);
}
```

### Non-field structs
Called _Unit-like_ structs. 

```rust
struct AlwaysEqual;

fn main() {
    let subject = AlwaysEqual;
}
```

### Debugging structs
An alternative to using `println!` is the `dbg!` macro which can be used without explicitly turning on struct-oriented debugging information in your code. But you need to pass the data going to `dbg!` as a reference because otherwise it would take ownership of the data. Inversely, `println!` only uses data as references so there's no need to manually pass in as references. 

Additionally, `dbg!` prints out the file and line number to the terminal so it could be more useful in debugging scenarios. 


## Methods
Like functions, but defined within the confines of a struct and their first parameter is always `self` which represents the instnace of the struct the method is being called on. 

The main reason for using methods, opposed to loose functions, is to organize functions around specific types. It's a concise way to gather functions related to a specific type into one area of the code. 

While it's possible to move ownership to a method, by default (an 99% of the time) you'll want to just pass a reference, written as `&self` in the method's function signature. 

Also, note you can use the same name from a field to use for a method.

## Associated functions
Similar to methods, but don't have the `self` as a parameter. Often used for constructors that will return a new instance of the struct. 

To call associated functions you use the `::` syntax, like `String::from("hello");`.

## Multiple impl blocks
Each struct is allowed to have multiple implmentation blocks. 

# Enums and pattern matching
Enums give you the capability to say whether a value is one of a possible set of values. 

Variations of an enum are namespaced under its identifier and we use `::` to separate the two:

```rust
enum IpAddrKind {
    V4,
    v6,
}


let four = IpAddrKind::V4;
let four = IpAddrKind::V6;
```

We can then embed data in each enum variant like so:

```rust
enum IpAddrKind {
    V4(String),
    V6(String),
}

let home = IpAddrKind::V4(String::from("127.0.0.1"));
let loopback = IpAddrKind::V6(String::from("::1"));
```

This way there's no need for an additional struct to hold the data.

Another benefit of storing data in enums is that the underlying type signature of the data doesn't have to be the same across variants:

```rust
enum IpAddrKind {
    V4(u8, u8, u8, u8),
    V6(String),
}
```

But you don't have to stop here; you can also embed structs and even enums within enums. Additionally, you can define methods on enums using the same `impl` keyword. 

## Option enum
Defined in the standard library. An option is simply something or nothing. Like a unit in `hoon`.

Rust does not have `null` as a concept; but rather has an enum that allows you to encode this concept if you want: the enum is `Option<T>`, defined as:

```rust
enum Option {
    None,
    Some<T>.
}
```

It's so useful that it's included in the prelude. You can use Some and None without the Option prefix. 

Just like with `hoon` units, you need to "strip the unit" in order to operate on the underlying data as the static type system recognizes the `Option<T>` type and `T` to be two separate types. To do this, check out the methods available for `Option<T>` in the documentation: https://doc.rust-lang.org/std/option/enum.Option.html.

Using `match` will come in handy to separate code blocks that operate on the data depending on which _option_ is present:

## Match

