# Updating 
`rustup` is the general command to install, update, etc. e.g. `rustup update` & `rustup self uninstall`.

Local Rust documentation can be found by running `rustup doc`. This will open in your browser.

# Naming
Use snake_case for file names.

# Anatomy of a rust program
## Construction
The `main()` function is the program entry point just like C programs. It's always the first code that runs in every executable Rust program. 

So with a simple program such as this:
```rust
fn main() {
    println!("hello world");
}
```

The `!` at the end of `println` indicates it's running as a macro. Will learn more about this later, but for now just note macros run by different rules than functions.

Additionally, most lines in Rust code ends with `;`.

## Compiling and running
These are separate steps; like with C programs after compiling there's an executable of the program that you'll run.

Rust is an "ahead-of-time compiled language" meaning you can build a program and send the executable for someone else to run (even without having Rust installed). Alternatively, in languages like Ruby, Javascript, and Python they'd need the respective languages installed in order to run the program, but compilation and running the program happens in one command.

# Cargo!
Rust's build system and package manager. 

Cargo comes installed with Rust; `cargo --version`.

To create a cargo package run: `cargo new <project_name>`. This will generate a "binary application package" - a directory along with a Cargo.toml, .gitignore (if one hasn't already been initalized), and a `src/main.rs` file.

The `Cargo.toml` is Rust's config format. Packages in Rust are referred to as crates. Cargo expects your source files to live in `src/`. This is why `main.rs` is auto-placed here. The top-level directory is for any files unrelated to code: i.e. README, config, license info, etc.

If you already have a directory, not generated by `cargo`, you can run `cargo init` to build it internally.

## Buildling and runing a cargo project
Instead of compiling your program manually - this would be complicated if you have multiple source files - you can simply run `cargo build` to compile the crate.

This will create an executable file in `target/debug/<project_name>` within your project directory. You can run the executable with `./target/debug/<project_name>`.

By building via cargo, you'll also have a `Cargo.lock` file in the top-level directory. This file keeps track of the exact versions of your deps in your project; cargo manages the contents of this file for you.

Alterntatively, you can more simply build and run the program in one swoop with `cargo run`.

Then to check code to make sure it compiles without generating an exectuable, run: `cargo check`. If you don't need to run the program - this is a must faster process as it doesn't ahve to build the executable. It's highly recommended to use this if you check your work as you go along, as you'll save a lot of time in the long run.

## Releasing cargo
`cargo build --release` to compile to an executable with optimizations. It'll also create an executable in `target/release` instead of `target/debug`. Notably, building for release takes longer because Rust is optimizing it so it's not recommended to use this regularly while in the development phase. 


# Creating a larger program
Importing deps from the standard library can be done by  using `use` keyword at the top of your program. Rust has a set of items defined in the std library that it brings into the scope of every program, called the _prelude_; found here: https://doc.rust-lang.org/std/prelude/index.html. However, if what you need is not listed in here,  you'll need to manually import it. This is why the `println!` macro didn't need an import module earlier.

## Storing values and variables
You can declare variables with `let`. Variables are immutable by default, meaning once we give the variable a value it won't change (more about this in Ch. 3). However, to make a valuable mutable we add `mut` before the variable name:
```rust
let apples = 5; // immutable
let mut apples = 5; // mutable
```

You can associate functions to specific types (e.g. `String::new();`) which is kind of like a class method; you can apply some inherent function on the associated type. In the example, a new, empty `String` is generated. 

`&` indicates that an argument is a _reference_, which gives you a way to let multiple parts of your code access one piece of data without needing to copy that data into memory multiple times. Like variables, references are immutable by default. Hence you'd need to write `&mut apples` instead of just `&apples` to make it mutable. More on references in chapter 4.

If a function produces a result - something like Err or Ok - you'll need to handle those cases with `.expect` which allows you to define which options produce what to the user; an error message or a note indicating success. Like C programs you have to handle these, otherwise you'll get a warning. 

When printing the value of a variable, you can do so by simply placing the variable name in `{}` braces. 

Leftoff: Generating a Secret Number






