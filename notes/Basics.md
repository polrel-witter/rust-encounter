# Updating 
`rustup` is the general command to install, update, etc. e.g. `rustup update` & `rustup self uninstall`.

Local Rust documentation can be found by running `rustup doc`. This will open in your browser.

# Naming
Use snake_case for file names.

# Anatomy of a rust program
## Construction
The `main()` function is the program entry point just like C programs. It's always the first code that runs in every executable Rust program. 

So with a simple program such as this:
```rust
fn main() {
    println!("hello world");
}
```

The `!` at the end of `println` indicates it's running as a macro. Will learn more about this later, but for now just note macros run by different rules than functions.

Additionally, most lines in Rust code ends with `;`.

## Compiling and running
These are separate steps; like with C programs after compiling there's an executable of the program that you'll run.

Rust is an "ahead-of-time compiled language" meaning you can build a program and send the executable for someone else to run (even without having Rust installed). Alternatively, in languages like Ruby, Javascript, and Python they'd need the respective languages installed in order to run the program, but compilation and running the program happens in one command.

# Cargo!
Rust's build system and package manager. 

Cargo comes installed with Rust; `cargo --version`.

To create a cargo package run: `cargo new <project_name>`. This will generate a "binary application package" - a directory along with a Cargo.toml, .gitignore (if one hasn't already been initalized), and a `src/main.rs` file.

The `Cargo.toml` is Rust's config format. Packages in Rust are referred to as crates. Cargo expects your source files to live in `src/`. This is why `main.rs` is auto-placed here. The top-level directory is for any files unrelated to code: i.e. README, config, license info, etc.

If you already have a directory, not generated by `cargo`, you can run `cargo init` to build it internally.

## Buildling and runing a cargo project
Instead of compiling your program manually - this would be complicated if you have multiple source files - you can simply run `cargo build` to compile the crate.

This will create an executable file in `target/debug/<project_name>` within your project directory. You can run the executable with `./target/debug/<project_name>`.

By building via cargo, you'll also have a `Cargo.lock` file in the top-level directory. This file keeps track of the exact versions of your deps in your project; cargo manages the contents of this file for you.

Alterntatively, you can more simply build and run the program in one swoop with `cargo run`.

Then to check code to make sure it compiles without generating an exectuable, run: `cargo check`. If you don't need to run the program - this is a must faster process as it doesn't ahve to build the executable. It's highly recommended to use this if you check your work as you go along, as you'll save a lot of time in the long run.

## Releasing cargo
`cargo build --release` to compile to an executable with optimizations. It'll also create an executable in `target/release` instead of `target/debug`. Notably, building for release takes longer because Rust is optimizing it so it's not recommended to use this regularly while in the development phase. 





